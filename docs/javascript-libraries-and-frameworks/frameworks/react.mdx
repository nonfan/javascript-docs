import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';
import CodeDemo from '../../../src/components/CodeDemo';

# React

> [react](https://zh-hans.react.dev/) 用于构建 Web 和原生交互界面的库。

## React 简介

### 什么是React？

React 是一个用于构建用户界面的 JavaScript 库，最初由 Facebook 开发和维护。它主要用于开发单页面应用程序 (SPA)，通过构建可复用的组件来创建动态和响应迅速的用户界面。React 的核心理念是声明式编程和组件化，这使得开发和维护复杂的应用程序变得更加容易。

### React的特点

**[组件化](#组件)**：React 采用组件化开发的方式，将用户界面分解成一个个独立的组件，这些组件可以重复使用和组合，提升了代码的可维护性和可复用性。

**声明式**：React 使用声明式编程来描述用户界面状态，这使得代码更加直观和易于理解。开发者只需要描述应用在某个状态下应该是什么样子，而不需要手动操作 DOM 来更新界面。

**虚拟 DOM**：React 通过使用虚拟 DOM 来提升性能。虚拟 DOM 是 React 在内存中构建的一棵轻量级 DOM 树，当状态发生变化时，React 通过比较虚拟 DOM 和真实 DOM 的差异（diffing），仅更新需要改变的部分，从而提高了性能。

**单向数据流**：React 中的数据流是单向的，即数据只能从父组件传递到子组件，这使得数据管理变得更加简单和可预测。

**高效**：由于虚拟 DOM 和高效的 diff 算法，React 可以在保持性能的同时频繁更新 UI。

### JSX

[JSX](#javascriptxml)（JavaScript XML）是 React 提供的一种语法扩展，允许在 JavaScript 代码中直接编写 HTML 结构。JSX 使得代码更加直观和简洁，同时提高了代码的可读性。

```jsx
const element = <h1>Hello, world!</h1>;
```

JSX 实际上是被 Babel 转译成普通的 JavaScript 代码，例如上面的代码会被转译成：

```js
const element = React.createElement('h1', null, 'Hello, world!');
```

### 虚拟DOM

虚拟 DOM 是 React 的一大亮点，它是 React 在内存中维护的一棵轻量级 DOM 树。当组件的状态发生变化时，React 会先在虚拟 DOM 中更新视图，然后再计算出最小的变更部分，最后只更新真实 DOM 中需要变化的部分。这样可以避免不必要的 DOM 操作，从而提升性能。

**虚拟 DOM 的工作流程如下：**

1. 当组件状态或属性改变时，React 重新渲染虚拟 DOM。
2. React 比较新旧虚拟 DOM 的差异，计算出需要更新的部分。
3. React 将变化的部分更新到真实 DOM 上。

## 安装和环境配置

### 创建React项目

Create React App 是官方提供的一个工具，用于快速创建和配置 React 应用程序。它可以帮助开发者避免繁琐的配置步骤，专注于编写代码。

安装 Node.js 和 npm：在创建 React 项目之前，需要确保已经安装了 Node.js 和 npm（Node 包管理器）。可以从 [Node.js 官网](https://nodejs.org/en) 下载并安装最新版本。

```bash title="创建项目"
# 安装最新版本
npx create-react-app@latest project_name

# 进入项目
cd project_name

# 运行
npm start
```

### 项目结构介绍

Create React App 创建的项目典型结构如下：

```text
my-app/
├── node_modules/              # 包含项目的所有依赖包
├── public/                    # 静态资源
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
├── src/                       # 项目文件
│   ├── App.css
│   ├── App.js
│   ├── App.test.js
│   ├── index.css              # 全局样式文件
│   ├── index.js               # React 入口文件
│   ├── logo.svg
│   ├── reportWebVitals.js
│   └── setupTests.js
├── .gitignore                 # git忽略文件
├── package.json               # node工具包管理文件
├── package-lock.json
└── README.md                  # 项目的自述文件
```

### 常用开发工具和插件

**代码编辑器：[IDEA](https://www.jetbrains.com/idea/)**

**浏览器开发插件：[React Developer Tools](https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=zh-CN&utm_source=ext_sidebar)**

**版本控制工具：[git](https://git-scm.com/downloads)**

## JavaScriptXML

### 什么是 JSX？

JSX (JavaScript XML) 是一种语法扩展，允许在 JavaScript 代码中编写类似 HTML 的结构。它被 React 用来描述用户界面。尽管看起来像 HTML，JSX 实际上会被 Babel 转译成 JavaScript 函数调用，从而生成 React 元素。这使得定义组件的 UI 结构更加直观和简洁。

### JSX 语法

JSX 语法允许在 JavaScript 中嵌入 XML/HTML 代码。以下是一些常见的 JSX 语法示例：

```js title="示例"
const element = <h1>Hello, world!</h1>;

// 嵌套元素
const element2 = (
  <div>
    <h1>Hello, world!</h1>
    <p>Welcome to learning React!</p>
  </div>
);
```

在 React JSX 语法中绑定属性、类名和事件和HTML略有不同，属性和事件均采用小驼峰命名法:

```js title="属性"
const element = <input type="text" defaultValue="Hello" />;
```

```js title="事件"
const handleClick = () => {
  console.log('Button clicked!');
};

const element = <button onClick={handleClick}>Click Me</button>;
```

由于 `class` 是 JavaScript 的保留字，React 使用 `className` 来指定 CSS 类名：

```js title="类名"
const element = <div className="my-class"></div>;
```

_表达式与 JSX_

在 JSX 中可以使用大括号 `{}` 来嵌入 JavaScript 表达式，这些表达式会被求值并插入到最终的输出中。

```js title="变量"
const name = 'John';
const element = <h1>Hello, {name}!</h1>;
```

```js title="函数调用"
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Harper',
  lastName: 'Perez',
};

const element = <h1>Hello, {formatName(user)}!</h1>;
```

```js title="三元运算符"
const isLoggedIn = true;
const element = <div>{isLoggedIn ? 'Welcome back!' : 'Please sign up.'}</div>;
```

```js title="嵌套表达式"
const element = (
  <div>
    <h1>{name ? `Hello, ${name}!` : 'Hello, Stranger!'}</h1>
  </div>
);
```

_只能返回一个根元素_

如果想要在一个组件中包含多个元素，需要用一个父标签把它们包裹起来。

```jsx
const element = (
  <div>
    <h1>海蒂·拉玛的待办事项</h1>
    <img
      src="https://i.imgur.com/yXOvdOSs.jpg"
      alt="Hedy Lamarr"
      class="photo"
    />
  </div>
);
```

如果你不想在标签中增加一个额外的 `<div>`，可以用 `<>` 和 `</>` 元素来代替：

这个空标签被称作 Fragment。React Fragment 允许你将子元素分组，而不会在 HTML 结构中添加额外节点。

**为什么多个 JSX 标签需要被一个父元素包裹？**

> JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。

_标签必须闭合_

JSX 要求标签必须正确闭合。像 `<img>` 这样的自闭合标签必须书写成 `<img />`，而像 `<li>oranges` 这样只有开始标签的元素必须带有闭合标签，需要改为 `<li>oranges</li>`。

_使用驼峰式命名法给大部分属性命名_

JSX 最终会被转化为 JavaScript，而 JSX 中的属性也会变成 JavaScript 对象中的键值对。在你自己的组件中，经常会遇到需要用变量的方式读取这些属性的时候。但 JavaScript 对变量的命名有限制。例如，变量名称不能包含 `-` 符号或者像 `class` 这样的保留字。

这就是为什么在 React 中，大部分 HTML 和 SVG 属性都用驼峰式命名法表示。例如，需要用 `strokeWidth` 代替 `stroke-width`。由于 `class` 是一个保留字，所以在 React 中需要用 `className` 来代替。

_使用 “双大括号”：JSX 中的 CSS 和 对象_

除了字符串、数字和其它 JavaScript 表达式，你甚至可以在 JSX 中传递对象。对象也用大括号表示，例如 `{ name: "Hedy Lamarr", inventions: 5 }`。因此，为了能在 JSX 中传递，你必须用另一对额外的大括号包裹对象：`person={{ name: "Hedy Lamarr", inventions: 5 }}`。

你可能在 JSX 的内联 CSS 样式中就已经见过这种写法了。React 不要求你使用内联样式（使用 CSS 类就能满足大部分情况）。但是当你需要内联样式的时候，你可以给 `style` 属性传递一个对象：

```jsx
export default function TodoList() {
  return (
    <ul
      style={{
        backgroundColor: 'black',
        color: 'pink',
      }}
    >
      <li>打篮球</li>
      <li>看书</li>
      <li>写代码</li>
    </ul>
  );
}
```

```jsx title="拆解Style"
export default function TodoList() {
  // success-start
  let style = {
    backgroundColor: 'black',
    color: 'pink',
  };
  // success-end

  return (
    <ul style={style}>
      <li>打篮球</li>
      <li>看书</li>
      <li>写代码</li>
    </ul>
  );
}
```

所以当你下次在 JSX 中看到 `{{` 和 `}}` 时，就知道它只不过是包在大括号里的一个对象罢了！

### JSX 与 HTML 的区别

尽管 JSX 看起来非常像 HTML，但它们之间有一些重要的区别：

**属性命名：**

> 在 JSX 中，属性名称采用驼峰命名法，如 `className`、`onClick`，而在 HTML 中是用小写，如 `class`、`onclick`。

```jsx title="jsx"
const element = <div className="container"></div>;
```

```html title="html"
<div class="container"></div>
```

**自闭合标签：**

> 在 JSX 中，所有自闭合标签必须显式关闭，如 `<img />`、`<input />`，而在 HTML 中则可以省略斜杠。

```jsx title="jsx"
const element = <img src="image.png" />;
```

```html title="html"
<img src="image.png" />
```

**JavaScript 表达式：**

> 在 JSX 中，可以使用 `{}` 来嵌入 JavaScript 表达式，而在 HTML 中只能使用静态值。

```jsx title="jsx"
const name = 'John';

const element = <h1>Hello, {name}!</h1>;
```

```html title="html"
<h1>Hello, John!</h1>
```

**注释：**

> 在 JSX 中，注释使用 `{/*  */}`，而在 HTML 中使用 `<!-- -->`。

```jsx title="jsx"
const element = <div>{/* 注释内容 */}</div>;
```

```html title="html"
<!-- 注释内容 -->
```

:::note JSX 注释
在 JSX 中，花括号 `{}` 用来嵌入 JavaScript 表达式，因此可以利用花括号内的注释形式 `/* */` 来实现 JSX 注释。
:::

## 组件

组件是 React 的基本构建块。每个组件可以看作是一个独立的、可复用的 UI 单位。组件分为两类：类组件（Class Component）和函数组件（Function Component）。类组件使用 ES6 类来定义，包含状态和生命周期方法；函数组件则是简单的 JavaScript 函数，可以使用 [React Hooks](#hooks) 来管理状态和副作用。

自从 React 16.8 引入了 Hooks 之后，函数组件变得更加强大和灵活，能够处理以前只有类组件才能处理的复杂状态逻辑和生命周期方法。

<Tabs>
  <TabItem value="类组件">
    <CodeDemo filePath="/react/classComponent.txt" />
  </TabItem>
  <TabItem value="函数组件">
    <CodeDemo filePath="/react/funcComponent.txt" />
  </TabItem>
</Tabs>

### 定义组件

_第一步：导出组件_

`export default` 前缀是一种 JavaScript 标准语法（非 React 的特性）。它允许你导出一个文件中的主要函数以便你以后可以从其他文件引入它。

_第二步：定义函数_

使用 `function Welcome() { }` 定义名为 Profile 的 JavaScript 函数。

:::warning
React 组件是常规的 JavaScript 函数，但组件的名称必须以大写字母开头，否则它们将无法运行！
:::

_第三步：添加标签_

```jsx
return <div>Hello World!</div>;
```

返回语句可以全写在一行上，但是，如果你的标签和 `return` 关键字不在同一行，则必须把它包裹在一对括号中，如下所示：

```jsx
return (
  <div>
    <h1>Hello World!</h1>
  </div>
);
```

:::warning
没有括号包裹的话，任何在 `return` 下一行的代码都将被忽略！
:::

### 嵌套和组合组件

无论类组件还是函数组件都可以嵌套和组合，以创建更复杂的 UI。以函数组件为例：

```jsx
function App() {
  return (
    <div>
      <Header />
      <Main />
      <Footer />
    </div>
  );
}

function Header() {
  return <h1>Header</h1>;
}

function Main() {
  return (
    <div>
      <Sidebar />
      <Content />
    </div>
  );
}

function Sidebar() {
  return <div>Sidebar</div>;
}

function Content() {
  return <div>Content</div>;
}

function Footer() {
  return <h1>Footer</h1>;
}
```

:::warning
组件可以渲染其他组件，但是请不要嵌套他们的定义：

```jsx
function App() {
  // 永远不要在组件中定义组件
  // error-start
  function Header() {
    return <h1>Header</h1>;
  }
  // error-end
  return (
    <div>
      <Header />
    </div>
  );
}
```

:::

### 组件的导入导出

这是 JavaScript 里两个主要用来导出值的方式：**默认导出**和**具名导出**。到目前为止，我们的示例中只用到了默认导出。但你可以在一个文件中，选择使用其中一种，或者两种都使用。一个文件里有且仅有一个默认导出，但是可以有任意多个具名导出。

<Tabs>
  <TabItem value="默认导出">
    <CodeDemo filePath="/react/exportDefault.txt" />
  </TabItem>
  <TabItem value="具名导出">
    <CodeDemo filePath="/react/export.txt" />
  </TabItem>
</Tabs>

<Tabs>
  <TabItem value="默认导入">
    <CodeDemo filePath="/react/importExportDefault.txt" />
  </TabItem>
  <TabItem value="具名导入">
    <CodeDemo filePath="/react/importExport.txt" />
  </TabItem>
</Tabs>

### 组件的 props

`props`（属性）是 React 组件的输入参数，用于传递数据和事件处理函数。`props` 是从父组件传递给子组件的，因此子组件不能修改 `props`，它们是只读的。

#### 如何使用 props？

1. 传递 props

父组件可以通过 JSX 属性语法传递 `props` 给子组件。

```js title="传递 props 示例"
import Profile from './Profile.jsx';

function App() {
  return <Profile name="MoFan" age="18" address="China" />;
}
```

2. 访问 props

子组件可以通过函数参数（对于函数组件）或 `this.props`（对于类组件）访问 `props`。

```js
function Profile(props) {
  return (
    <h1>
      我是 {props.name}， 今年 {props.age}, 居住在 {props.address}
    </h1>
  );
}

export default Profile;
```

通常你不需要整个 props 对象，所以可以将它解构为单独的 props。

```js title="解构 props"
function Profile({ name, age, address }) {
  return (
    <h1>
      我是 {name}， 今年 {age}, 居住在 {address}
    </h1>
  );
}

export default Profile;
```

如果你想在没有指定值的情况下给 `prop` 一个默认值，你可以通过在参数后面写 `=` 和默认值来进行解构：

```js
// default
function Profile({ name, age = 20, address }) {
  return (
    <h1>
      我是 {name}， 今年 {age}, 居住在 {address}
    </h1>
  );
}

export default Profile;
```

如果子组件 Profile 仍需要传递 props 给下一个子组件 Avatar，如下：

```jsx title="Profile.jsx"
import Avatar from './Avatar.jsx';

function Profile({ name, age, address }) {
  return (
    <div className="card">
      //error-start
      {/*不推荐写法*/}
      <Avatar name="MoFan" age="18" address="China" />
      // error-end
    </div>
  );
}
```

重复代码没有错（它可以更清晰）。但有时你可能会重视简洁。一些组件将它们所有的 props 转发给子组件，正如 Profile 转给 Avatar 那样。因为这些组件不直接使用他们本身的任何 props，所以使用更简洁的“展开”语法是有意义的：

```jsx title="Profile.jsx"
import Avatar from './Avatar.jsx';

function Profile(props) {
  return (
    <div className="card">
      //success-start
      {/*推荐写法*/}
      <Avatar {...props} />
      // success-end
    </div>
  );
}
```

#### props 的类型

`props` 可以是任意类型的数据，包括字符串、数字、数组、对象、函数等。

```js
function App() {
  const user = {
    name: 'MoFan',
    age: 25,
  };

  return <Greeting user={user} />;
}

function Greeting(props) {
  return (
    <div>
      <h1>Hello, {props.user.name}</h1>
      <p>Age: {props.user.age}</p>
    </div>
  );
}
```

#### props 验证

可以使用 `prop-types` 库对 `props` 进行类型检查，确保传递的 `props` 符合预期。

```bash npm2yarn
npm i prop-types
```

```js title="用法"
import PropTypes from 'prop-types';

function Greeting(props) {
  return <h1>Hello, {props.name}</h1>;
}

Greeting.propTypes = {
  name: PropTypes.string,
};
```

#### 传递子组件（Children）

React 有一个特殊的 `props`，称为 `children`，用来传递嵌套在组件中的子元素。

```jsx
function Wrapper(props) {
  return <div className="wrapper">{props.children}</div>;
}

function App() {
  return (
    <Wrapper>
      <h1>Hello, world!</h1>
    </Wrapper>
  );
}
```

在上述示例中，`<h1>` 标签作为 Wrapper 组件的子元素，通过 `props.children` 传递给 Wrapper 组件。

#### 子组件传递 props 到父组件

子传父的原理也是 props，只是变换思维，父组件向子组件传递函数，子组件调用函数，传递参数给父组件。

```jsx title="FatherComponent.jsx"
// useState 是一个 hook 用于保存状态的，后续会有所讲解
import { useState } from 'react';
import SonComponent from './SonComponent.jsx';

function FatherComponent() {
  const [user, setUser] = useState(null);

  function getUser(user) {
    console.log(user);
    setUser(user);
  }

  return (
    <div>
      <h1>父组件: {JSON.stringify(user)}</h1>
      <SonComponent getUser={getUser} />
    </div>
  );
}

export default FatherComponent;
```

```jsx title="SonComponents.jsx"
import React from 'react';

function SonComponent(props) {
  function transferDataForFather() {
    props.getUser({
      name: '用户名',
      age: '18',
      address: 'China',
    });
  }

  return (
    <button onClick={transferDataForFather}>
      子组件: 点击传递数据给父组件
    </button>
  );
}

export default SonComponent;
```

### 组件的状态（state）

在 React 中，组件的状态（state）是组件内部的数据源，它是一个能够改变组件外观和行为的对象。状态与 `props` 的不同之处在于，`props` 是由父组件传递的是只读的；而状态是由组件自身管理的，可以通过特定的方法进行更新。状态主要用于需要动态更新或变化的数据。

`useState` Hook 提供了这两个功能：

- State 变量 用于保存渲染间的数据。
- State setter 函数 更新变量并触发 React 再次渲染组件。

```jsx title="示例"
import { useState } from 'react';

function App() {
  // default
  let [count, setCount] = useState(0);

  function handleAdd() {
    setCount(++count);
  }

  return (
    <div>
      <h1>计算 {count}</h1>
      <button onClick={handleAdd}>+</button>
    </div>
  );
}

export default App;
```

:::info
这里的 `[` 和 `]` 语法称为数组解构，它允许你从数组中读取值。 `useState` 返回的数组总是正好有两项。
:::

#### 剖析 useState

当你调用 `useState` 时，你是在告诉 React 你想让这个组件记住一些东西：

```jsx
let [count, setCount] = useState(0);
```

:::tip 最佳实践
惯例是将这对返回值命名为 `const [thing, setThing]`。你也可以将其命名为任何你喜欢的名称，但遵照约定俗成能使跨项目合作更易理解。
:::

#### 赋予一个组件多个 state 变量

<Tabs>
  <TabItem value="示例">

    ```js
    const [index, setIndex] = useState(0);
    const [showMore, setShowMore] = useState(false);
    ```

  </TabItem>
  
  <TabItem value="React 如何知道返回哪个 state">

    你可能已经注意到，`useState` 在调用时没有任何关于它引用的是哪个 `state` 变量的信息。没有传递给 `useState` 的“标识符”，它是如何知道要返回哪个 `state` 变量呢？它是否依赖于解析函数之类的魔法？答案是否定的。

    相反，为了使语法更简洁，在同一组件的每次渲染中，Hooks 都依托于一个稳定的调用顺序。这在实践中很有效，因为如果你遵循上面的规则（“只在顶层调用 Hooks”），Hooks 将始终以相同的顺序被调用。此外，[linter](https://www.npmjs.com/package/eslint-plugin-react-hooks) 插件也可以捕获大多数错误。

    在 React 内部，为每个组件保存了一个数组，其中每一项都是一个 `state` 对。它维护当前 `state` 对的索引值，在渲染之前将其设置为 “0”。每次调用 `useState` 时，React 都会为你提供一个 state 对并增加索引值。你可以在文章 [React Hooks: not magic, just arrays](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e) 中阅读有关此机制的更多信息。

    <CodeDemo filePath="/react/stateExample.txt" title="index.js"/>
    <CodeDemo filePath="/react/stateExampleHtml.txt" title="index.html"/>

  </TabItem>
</Tabs>

#### State 是隔离且私有的

State 是屏幕上组件实例内部的状态。换句话说，如果你渲染同一个组件两次，每个副本都会有完全隔离的 `state`！改变其中一个不会影响另一个。

试着点击每个计算按钮。你会注意到它们的 `state` 是相互独立的

```jsx title="示例"
import { useState } from 'react';

function Count() {
  let [count, setCount] = useState(0);
  function handleAdd() {
    setCount(++count);
  }

  return (
    <div>
      <h1>计算 {count}</h1>
      <button onClick={handleAdd}>+</button>
    </div>
  );
}

function App() {
  return (
    <div>
      <Count />
      <Count />
    </div>
  );
}

export default App;
```

#### 更新 state 中的对象

`state` 中可以保存任意类型的 JavaScript 值，包括对象。但是，你不应该直接修改存放在 React state 中的对象。相反，当你想要更新一个对象时，你需要创建一个新的对象（或者将其拷贝一份），然后将 `state` 更新为此对象。

##### 什么是 mutation？

mutation 指的是对数据进行直接修改或改变, 当你直接修改 state 对象时，就制造了一个 mutation：

```js
const [position, setPosition] = useState({ x: 0, y: 0 });
position.x = 5;
```

然而，虽然严格来说 React state 中存放的对象是可变的，但你应该像处理数字、布尔值、字符串一样将它们视为不可变的。因此你应该替换它们的值，而不是对它们进行修改。

##### 将 state 视为只读的

换句话说，你应该把所有存放在 state 中的 JavaScript 对象都视为只读的。

通过使用 setPosition，你在告诉 React：使用这个新的对象替换 position 的值,使用这个新的对象替换 position 的值。

```js
setPosition({
  x: e.clientX,
  y: e.clientY,
});
```

#### 更新 state 中的数组

数组是另外一种可以存储在 `state` 中的 JavaScript 对象，它虽然是可变的，但是却应该被视为不可变。同对象一样，当你想要更新存储于 `state` 中的数组时，你需要创建一个新的数组（或者创建一份已有数组的拷贝值），并使用新数组设置 `state`。

##### 在没有 mutation 的前提下更新数组

在 JavaScript 中，数组只是另一种对象。同对象一样，你需要将 React state 中的数组视为只读的。这意味着你不应该使用类似于 `arr[0] = 'bird'` 这样的方式来重新分配数组中的元素，也不应该使用会直接修改原始数组的方法，例如 `push()` 和 `pop()`。

相反，每次要更新一个数组时，你需要把一个新的数组传入 `state` 的 `setting` 方法中。为此，你可以通过使用像 `filter()` 和 `map()` 这样不会直接修改原始值的方法，从原始数组生成一个新的数组。然后你就可以将 state 设置为这个新生成的数组。

下面是常见数组操作的参考表。当你操作 React state 中的数组时，你需要避免使用左列的方法，而首选右列的方法：

|          | 避免使用 (会改变原始数组)      | 推荐使用 (会返回一个新数组）  |
| -------- | ------------------------------ | ----------------------------- |
| 添加元素 | `push`，`unshift`              | `concat`，`[...arr]` 展开语法 |
| 删除元素 | `pop`，`shift`，`splice`       | `filter`，`slice`             |
| 替换元素 | `splice`，`arr[i] = ... ` 赋值 | `map`                         |
| 排序     | `reverse`，`sort`              | 先将数组复制一份              |

<Tabs>
  <TabItem value="添加元素">
    <CodeDemo filePath="/react/addElement.txt" />
  </TabItem>
  <TabItem value="删除元素">
    <CodeDemo filePath="/react/deleteElement.txt" />
  </TabItem>
  <TabItem value="替换元素">
    <CodeDemo filePath="/react/replaceElement.txt" />
  </TabItem>
  <TabItem value="插入元素">
    <CodeDemo filePath="/react/insertElement.txt" />
  </TabItem>
</Tabs>

##### 更新数组内部的对象

在 React 中更新数组内部的对象，通常需要找到要更新的对象，然后创建该对象的副本，对其进行修改，再将更新后的对象放回数组中。最后，通过调用 `setState` 来更新状态，从而触发重新渲染。以下是一些示例，演示如何更新数组内部的对象。

在下面的例子中，两个不同的艺术品清单有着相同的初始 `state`。他们本应该互不影响，但是因为一次 mutation，他们的 `state` 被意外地共享了，勾选一个清单中的事项会影响另外一个清单：

```js
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(initialList);

  function handleToggleMyList(artworkId, nextSeen) {
    const myNextList = [...myList];
    const artwork = myNextList.find(a => a.id === artworkId);
    // error-start
    artwork.seen = nextSeen;
    setMyList(myNextList);
    // error-end
  }

  function handleToggleYourList(artworkId, nextSeen) {
    const yourNextList = [...yourList];
    const artwork = yourNextList.find(a => a.id === artworkId);
    // error-start
    artwork.seen = nextSeen;
    setYourList(yourNextList);
    // error-end
  }

  return (
    <>
      <h1>艺术愿望清单</h1>
      <h2>我想看的艺术清单：</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>你想看的艺术清单：</h2>
      <ItemList artworks={yourList} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map(artwork => (
        <li key={artwork.id}>
          <label>
            <input
              type="checkbox"
              checked={artwork.seen}
              onChange={e => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

你可以使用 `map` 在没有 mutation 的前提下将一个旧的元素替换成更新的版本。

```js
setMyList(
  myList.map(artwork => {
    if (artwork.id === artworkId) {
      // 创建包含变更的*新*对象
      return { ...artwork, seen: nextSeen };
    } else {
      // 没有变更
      return artwork;
    }
  }),
);
```

##### 使用 Immer 编写简洁的更新逻辑

Immer 是一个帮助处理不可变数据结构的库，它允许你以更加简洁和直观的方式编写更新逻辑。通过使用 Immer，你可以直接“修改”状态，并且 Immer 会在幕后处理不可变性。

```bash npm2yarn
npm install immer
```

```jsx title="示例"
// success
import { produce } from 'immer';
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(initialList);

  function handleToggleMyList(artworkId, nextSeen) {
    // success-start
    const nextState = produce(myList, draft => {
      const artwork = draft.find(a => a.id === artworkId);
      artwork.seen = nextSeen;
    });
    // success-end

    setMyList(nextState);
  }

  function handleToggleYourList(artworkId, nextSeen) {
    const yourNextList = [...yourList];
    // success-start
    const nextState = produce(yourNextList, draft => {
      const artwork = draft.find(a => a.id === artworkId);
      artwork.seen = nextSeen;
    });
    // success-end

    setYourList(nextState);
  }

  return (
    <>
      <h1>艺术愿望清单</h1>
      <h2>我想看的艺术清单：</h2>
      <ItemList artworks={myList} onToggle={handleToggleMyList} />
      <h2>你想看的艺术清单：</h2>
      <ItemList artworks={yourList} onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map(artwork => (
        <li key={artwork.id}>
          <label>
            <input
              type="checkbox"
              checked={artwork.seen}
              onChange={e => {
                onToggle(artwork.id, e.target.checked);
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

### 条件渲染

通常你的组件会需要根据不同的情况显示不同的内容。在 React 中，你可以通过使用 JavaScript 的 `if` 语句、`&&` 和 `?:` 运算符来选择性地渲染 JSX。

#### 使用 if 语句

使用 `if` 语句来条件渲染时，可以在渲染逻辑中放置 `if` 语句并返回不同的 JSX。

```jsx
function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  } else {
    return <h1>Please sign up.</h1>;
  }
}

function App() {
  return <Greeting isLoggedIn={true} />;
}
```

**选择性地返回 null**

在一些情况下，你不想有任何东西进行渲染。比如，你不想显示已经打包好的物品。但一个组件必须返回一些东西。这种情况下，你可以直接返回 `null`。

```jsx
function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  } else {
    // default
    return null;
  }
}

function App() {
  return <Greeting isLoggedIn={true} />;
}
```

#### 使用逻辑 && 运算符

逻辑 `&&` 运算符常用于在某个条件为真时渲染某些内容。

```jsx
function Welcome(props) {
  const { name, isShowName } = props;
  return <h1>欢迎你 {isShowName && name}</h1>;
}

function App() {
  return <Welcome name="mofan" isShowName={true} />;
}
```

#### 使用三元运算符 ?:

三元运算符可以在一个表达式中实现简单的条件渲染。

```jsx
function UserGreeting(props) {
  return <h1>Welcome back!</h1>;
}

function GuestGreeting(props) {
  return <h1>Please sign up.</h1>;
}

function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  return isLoggedIn ? <UserGreeting /> : <GuestGreeting />;
}

function App() {
  return <Greeting isLoggedIn={false} />;
}
```

### 渲染列表

你可能经常需要通过 JavaScript 的数组方法 来操作数组中的数据，从而将一个数据集渲染成多个相似的组件。在这篇文章中，你将学会如何在 React 中使用 filter() 筛选需要渲染的组件和使用 map() 把数组转换成组件数组。

#### 使用 map 将数组转换成组件数组

`map()` 方法用于遍历数组，并对每个元素执行指定的操作，返回操作后的新数组。常用于将数组元素转换成 JSX 元素。

```jsx
function NumberList(props) {
  const numbers = props.numbers;

  // default-start
  const listItems = numbers.map(number => (
    <li key={number.toString()}>{number}</li>
  ));
  // default-end

  return <ul>{listItems}</ul>;
}

function App() {
  const numbers = [1, 2, 3, 4, 5, 6];
  return <NumberList numbers={numbers} />;
}
```

#### 使用 filter 筛选需要渲染的组件

`filter()` 方法用于筛选数组中的元素，返回符合条件的元素组成的新数组。

```jsx
function NumberList(props) {
  const numbers = props.numbers;
  // default
  const evenNumbers = numbers.filter(number => number % 2 === 0);

  return (
    <ul>
      {evenNumbers.map(number => (
        <li key={number.toString()}>{number}</li>
      ))}
    </ul>
  );
}

function App() {
  const numbers = [1, 2, 3, 4, 5, 6];
  return <NumberList numbers={numbers} />;
}
```

#### 必须设置 Key 值

直接放在 `map()` 方法里的 JSX 元素一般都需要指定 key 值！

这些 key 会告诉 React，每个组件对应着数组里的哪一项，所以 React 可以把它们匹配起来。这在数组项进行移动（例如排序）、插入或删除等操作时非常重要。一个合适的 key 可以帮助 React 推断发生了什么，从而得以正确地更新 DOM 树。

```jsx
<li key={number.toString()}>{number}</li>
```

:::danger 报错
不使用 Key, 会在控制台报错：Warning: Each child in a list should have a unique “key” prop.
:::

**key 需要满足的条件**

- key 值在兄弟节点之间必须是唯一的。 不过不要求全局唯一，在不同的数组中可以使用相同的 key。
- key 值不能改变，否则就失去了使用 key 的意义！所以千万不要在渲染时动态地生成 key。

**React 中为什么需要 key？**

设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件……

React 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 key 值也能让 React 在整个生命周期中一直认得它。

:::warning 陷阱
你可能会想直接把数组项的索引当作 key 值来用，实际上，如果你没有显式地指定 key 值，React 确实默认会这么做。但是数组项的顺序在插入、删除或者重新排序等操作中会发生改变，此时把索引顺序用作 key 值会产生一些微妙且令人困惑的 bug。

与之类似，请不要在运行过程中动态地产生 key，像是 `key={Math.random()}` 这种方式。这会导致每次重新渲染后的 key 值都不一样，_从而使得所有的组件和 DOM 元素每次都要重新创建_。这不仅会造成运行变慢的问题，更有可能导致用户输入的丢失。所以，使用能从给定数据中稳定取得的值才是明智的选择。

有一点需要注意，组件不会把 key 当作 props 的一部分。Key 的存在只对 React 本身起到提示作用。如果你的组件需要一个 ID，那么请把它作为一个单独的 prop 传给组件： `<Profile key={id} userId={id}` />。
:::

### 保持组件纯粹

保持组件纯粹（pure）指的是确保组件的渲染输出仅由其 props 和 state 决定，而不依赖于外部的副作用或全局状态。这有助于使组件更可预测、易于测试和调试。以下是一些保持组件纯粹的方法：

**无副作用的生命周期方法：**

- 避免在生命周期方法中执行副作用，如 API 请求或直接操作 DOM。
- 将这些操作放在适当的生命周期方法（如 `componentDidMount` 或 `useEffect`）中，并在需要时清理它们。

**使用纯函数组件：**

- 优先使用函数组件，而不是类组件。函数组件更容易保持纯粹，因为它们通常不涉及复杂的生命周期方法。
- 使用 `React.memo` 包装组件，以避免不必要的重新渲染。

**管理 state 和 props：**

- 确保组件只依赖其 `props` 和 `state` 渲染。避免在渲染过程中使用全局变量或外部状态。
- 使用 propTypes 和 TypeScript 类型检查，确保组件接收正确类型的 `props`。

**避免直接修改 props 和 state：**

- 永远不要直接修改 `props` 和 `state`，而是使用 setState 或 React hooks（如 useState）来更新状态。
- 使用不可变的数据结构，如对象和数组的拷贝，来确保 `state` 和 `props` 的不可变性。

**拆分大型组件：**

- 将大型组件拆分为更小、更专注的子组件，每个子组件只负责渲染其自身的一部分。
- 这样可以减少单个组件的复杂性，并使其更容易保持纯粹。

**使用 Context API 和 Redux 管理全局状态：**

- 使用 Context API 或 Redux 等状态管理库，将全局状态管理和组件逻辑分离开。
- 这样可以避免在纯粹组件中直接访问或修改全局状态。

:::info 使用严格模式检测不纯的计算
React 提供了 “严格模式”，在严格模式下开发时，它将会调用每个组件函数两次。通过重复调用组件函数，严格模式有助于找到违反这些规则的组件。

严格模式在生产环境下不生效，因此它不会降低应用程序的速度。如需引入严格模式，你可以用 `<React.StrictMode>` 包裹根组件。一些框架会默认这样做。
:::

```js title="React 入口文件默认使用严格模式"
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
```

### 事件处理

在 React 中，事件处理是构建交互式用户界面的重要部分。理解事件处理器、事件对象以及事件绑定与 this 的相关问题，是开发 React 应用程序的关键。

#### 事件处理器

事件处理器是处理用户交互操作的函数，通常在组件中定义并与特定的 DOM 元素或 React 元素相关联。在 React 中，事件处理器可以直接作为 JSX 元素的属性来指定。

```jsx title="示例"
function handleClick() {
  console.log('Button clicked!');
}

function Button() {
  return <button onClick={handleClick}>Click me</button>;
}
```

#### 事件对象

在处理事件时，React 将事件对象 event 作为参数传递给事件处理器函数。这个事件对象包含了与事件相关的信息，例如触发事件的元素、事件类型等。

```jsx
function handleChange(event) {
  console.log('Input value changed:', event.target.value);
}

function InputField() {
  return <input type="text" onChange={handleChange} />;
}
```

在 JSX 元素中绑定点击事件 handleChange 函数默认接收 event 参数，可以通过 `event.target.value` 获取输入框中的新值。

如果需要在绑定事件时传递参数，可以在绑定事件中使用箭头函数，如下示例：

```js
function InputField() {
  return <input type="text" onChange={event => handleChange(event, ...args)} />;
}
```

#### 事件绑定与 this

在 React 类组件中，事件处理函数默认情况下不会自动将 this 绑定到当前组件的实例。这是因为在 JavaScript 中，函数的执行上下文（即 this 的值）取决于函数如何被调用，而不是如何被定义。因此，当你将一个方法作为事件处理函数传递给 DOM 元素时，如果不进行额外的绑定处理，this 将会是 undefined 或者指向 window 对象（在严格模式下）。

<Tabs>
  <TabItem value="显式绑定 this">

    在类组件的构造函数中，使用 [bind](/api/basic-objects/function#functionprototypebind) 方法显式地将方法绑定到当前组件实例的 this 上。

    <CodeDemo filePath="/react/bindThis.txt"/>

  </TabItem>
  <TabItem value="使用箭头函数">

    箭头函数不会创建自己的 `this` 上下文，而是继承父级作用域的 `this`。因此，使用箭头函数定义方法可以确保方法内部的 `this` 指向当前组件的实例。

    <CodeDemo filePath="/react/arrowFunc.txt"/>

  </TabItem>
</Tabs>

### CSS Module

CSS Module 是一种让 CSS 变得模块化的解决方案，它允许你将 CSS 文件中的类名（class 名）映射为一个局部作用域内的对象。这意味着每个类名在引入它们的组件中都是唯一的，并且不会污染全局命名空间。

```css title="style.module.css"
.button {
  background-color: blue;
  color: white;
}
```

```jsx title="ButtonComponent.jsx"
import React from 'react';
import styles from './styles.module.css';

function ButtonComponent() {
  return <button className={styles.button}>Click me</button>;
}

export default ButtonComponent;
```

**使用变量和局部作用域**：你可以在 CSS Module 中使用变量，并且这些变量仅在当前模块中有效，不会影响全局。

```css title="styles.module.css"
:local {
  --primary-color: blue;
}

.button {
  background-color: var(--primary-color);
  color: white;
}
```

## 状态管理

状态管理是 React 组件的核心部分之一，涉及到如何定义、更新和传递数据。理解状态管理的基本概念和技术是开发 React 应用的关键。

### State 与 Props 的区别

在 React 中，State 和 Props 是两个不同的概念，它们在组件的数据管理和通信中扮演着不同的角色。

<Tabs>
  <TabItem value="State">
    
    - **定义**：State 是组件内部管理的数据，描述了组件的当前状态和行为。
    - **可变性**：State 是可变的，组件可以通过调用 `setState()` 方法来更新状态。
    - **作用范围**：State 是局部的，仅在定义它的组件内部有效。
    - **访问方式**：在类组件中通过 `this.state` 访问；在函数组件中通过 `useState` Hook 访问。

  </TabItem>
  <TabItem value="Props">

    - **定义**：Props 是从父组件传递给子组件的数据，用于组件间的数据传递。
    - **可变性**：Props 是不可变的，子组件无法直接修改 Props 的值。
    - **作用范围**：Props 是全局的，可以在父组件中传递给任意层级的子组件。
    - **访问方式**：在类组件中通过 `this.props` 访问；在函数组件中通过函数参数 `props` 访问。

  </TabItem>
</Tabs>

```js title="示例"
function ChildComponent(props) {
  return <div>{props.message}</div>;
}

function ParentComponent() {
  const [message, setMessage] = useState('Hello from state!');

  return <ChildComponent message={message} />;
}
```

### 状态提升

有时候，你希望两个组件的状态始终同步更改。要实现这一点，可以将相关 state 从这两个组件上移除，并把 state 放到它们的公共父级，再通过 props 将 state 传递给这两个组件。这被称为“状态提升”，这是编写 React 代码时常做的事。

```jsx title="示例"
import { useState } from 'react';

function BoilingVerdict({ celsius }) {
  if (celsius >= 100) {
    return <p>水沸腾了.</p>;
  } else {
    return <p>水没有沸腾</p>;
  }
}

function TemperatureInput({ temperature, onTemperatureChange }) {
  return (
    <fieldset>
      <legend>输入摄氏度:</legend>
      <input
        type="text"
        value={temperature}
        onChange={e => onTemperatureChange(e.target.value)}
      />
    </fieldset>
  );
}

function Calculator() {
  const [temperature, setTemperature] = useState('');
  return (
    <div>
      // default-start
      <TemperatureInput
        temperature={temperature}
        onTemperatureChange={setTemperature}
      />
      <BoilingVerdict celsius={parseFloat(temperature)} />
      // default-end
    </div>
  );
}

export default Calculator;
```

_受控组件和非受控组件_

通常我们把包含“不受控制”状态的组件称为“非受控组件”。例如，最开始带有 isActive 状态变量的 Panel 组件就是不受控制的，因为其父组件无法控制面板的激活状态。

相反，当组件中的重要信息是由 props 而不是其自身状态驱动时，就可以认为该组件是“受控组件”。这就允许父组件完全指定其行为。最后带有 isActive 属性的 Panel 组件是由 Accordion 组件控制的。

非受控组件通常很简单，因为它们不需要太多配置。但是当你想把它们组合在一起使用时，就不那么灵活了。受控组件具有最大的灵活性，但它们需要父组件使用 props 对其进行配置。

在实践中，“受控”和“非受控”并不是严格的技术术语——通常每个组件都同时拥有内部状态和 props。然而，这对于组件该如何设计和提供什么样功能的讨论是有帮助的。

当编写一个组件时，你应该考虑哪些信息应该受控制（通过 props），哪些信息不应该受控制（通过 state）。当然，你可以随时改变主意并重构代码。

### 使用 Context 深层传递参数

通常来说，你会通过 `props` 将信息从父组件传递到子组件。但是，如果你必须通过许多中间组件向下传递 `props`，或是在你应用中的许多组件需要相同的信息，传递 `props` 会变的十分冗长和不便。Context 允许父组件向其下层无论多深的任何组件提供信息，而无需通过 props 显式传递。

#### 传递 props 带来的问题

传递 `props` 是将数据通过 UI 树显式传递到使用它的组件的好方法。

但是当你需要在组件树中深层传递参数以及需要在组件间复用相同的参数时，传递 props 就会变得很麻烦。最近的根节点父组件可能离需要数据的组件很远，状态提升 到太高的层级会导致 “逐层传递 props” 的情况。

#### Context：传递 props 的另一种方法

在 React 中，Context 提供了一种在组件之间共享数据的方式，而不必通过显式地传递 `props` 层层传递数据。使用 Context 可以有效地解决跨多层级组件传递数据的繁琐问题。

_Context 主要由两部分组成：_

1. Provider（提供器）：负责提供数据的组件。它通过 `Context.Provider` 将数据传递给下层组件。
2. Consumer（消费者）：负责使用数据的组件。它通过 `Context.Consumer` 或 `useContext` Hook 来访问从 Provider 中传递下来的数据。

<Tabs>
  <TabItem value="Step 1：创建 Context">

    首先，你需要创建这个 context，并将其从一个文件中导出：

    <CodeDemo filePath="/react/context1.txt" title="ThemeContext.js"/>

  </TabItem>
  <TabItem value="Step 2：提供 Context">
    在应用程序的顶层组件中使用 `Context.Provider` 提供主题信息
    <CodeDemo filePath="/react/context2.txt" title="App.jsx"/>
  </TabItem>

  <TabItem value="Step 3：使用 Context">
    使用 `useContext` Hook 在任意组件消费。

    <CodeDemo filePath="/react/context3.txt" title="AnySonComponent.jsx"/>

    使用 `Context.Consumer` 在任意组件消费。

    <CodeDemo filePath="/react/context3-1.txt" title="AnySonComponent.jsx"/>

  </TabItem>
</Tabs>

## 生命周期

在 React 中，组件的生命周期方法和 Hooks 都用于处理组件在不同阶段的行为和副作用。下面是对比类组件生命周期方法和函数组件中的 Hooks 的常见用法和功能：

### 类组件

<Tabs>
  <TabItem value="componentDidMount">
    在组件挂载后调用，可以执行一次性的初始化操作，如获取远程数据、添加事件监听器等。
    
    <CodeDemo filePath="/react/componentDidMount.txt"/>
    
  </TabItem>
  <TabItem value="componentDidUpdate">
    在组件更新后调用，可以根据新的 props 或 state 执行额外的操作，如更新 DOM、发送网络请求等。

    <CodeDemo filePath="/react/componentDidUpdate.txt"/>

  </TabItem>
  <TabItem value="componentWillUnmount">
    在组件即将被卸载时调用，可以执行一些清理操作，如取消定时器、清除订阅等。

    <CodeDemo filePath="/react/componentWillUnmount.txt"/>

  </TabItem>
</Tabs>

### 函数组件

[useEffect](#useeffect) Hook 可以替代 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount`。通过传递不同的依赖数组，可以控制 `useEffect` 的触发时机和条件。

`useEffect` 内部的函数会在组件挂载后执行一次，之后会在每次组件更新时执行（除非指定了依赖项并且依赖项未发生变化时会跳过执行），同时也支持在组件卸载时执行清理操作。

```jsx
import React, { useEffect } from 'react';

function Example() {
  useEffect(() => {
    // 在组件更新后执行的操作
  }, [props]);

  useEffect(() => {
    // 在组件挂载后和更新后执行的操作
    console.log('Component mounted or updated');
    return () => {
      // 在组件卸载前执行的清理操作
      console.log('Component will unmount');
    };
  }, []); // 第二个参数为空数组，表示仅在组件挂载和卸载时执行

  return <div>Hello, world!</div>;
}
```

## React Hooks

### 什么是Hooks？

Hooks 是 React 中的一种特性，允许你在函数式组件中使用 React 的状态（state）和生命周期特性。通过 Hooks，可以在不编写类组件的情况下，复用状态逻辑、副作用逻辑（如数据获取、订阅等），以及更好地组织和抽象组件的逻辑。Hooks 的引入使得 React 组件的编写更加简洁、灵活，并提高了代码的可维护性和复用性。

#### Hooks 规则

在使用 React Hooks 时，有一些重要的规则需要遵循，以确保 Hooks 能够正确地工作和发挥其作用。以下是使用 React Hooks 的主要规则：

**1. 只在最顶层使用 Hook:**

不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 `useState` 和 `useEffect` 调用之间保持 hook 状态的正确。

**2. 只在 React 函数或 Hook 中调用 Hook:**

Hooks 只能在 React 的函数式组件中使用，以及自定义 Hook 中调用 Hooks。不能在普通的 JavaScript 函数中使用，也不能在类组件中使用。

**3. 按顺序调用 Hooks:**

在每次渲染时，Hooks 的调用顺序必须始终保持一致。React 依赖于 Hooks 调用顺序来正确地管理组件的状态和副作用。

**4. 命名规则：**

自定义 Hook 必须以 `use` 开头，这是 React 对自定义 Hook 的约定。例如，`useEffect`、`useState` 是 React 提供的内置 Hook 名称，而你自己定义的 Hook 应该遵循相同的命名规则，例如 `useCustomHook`。

### useState

在包含 `useState` hook 的函数组件进行第一次渲染时，它会根据传递给它的参数创建一个有状态的值，同时创建一个用于更新该值的函数。

<Tabs>
  <TabItem value="设置初始状态">
    需要将初始值传递给 `useState`。接收单个参数，该参数可以是 JavaScript 的任何数据类型（或计算结果为单个值的表达式）或函数。

    如果不向 `useState` 传递参数，则将创建初始值为 undefind 的状态变量。

    初始值只会在组件的初始渲染中起作用，后续渲染时会被忽略。React称之为惰性初始状态。
    <CodeDemo filePath="/react/useState1.txt"/>

  </TabItem>
  <TabItem value="使用 Setter 函数">
    
    `useState` 返回的 setter 函数将触发渲染。如果将 setter 函数向下传递给子组件并从该子组件调用它，它仍然会操作创建它的原始变量。
    
    <CodeDemo filePath="/react/useState2.txt"/>
  </TabItem>
  <TabItem value="向 Setter 传递值">
    
    `useState` 返回的 setter 函数将触发渲染。如果将 setter 函数向下传递给子组件并从该子组件调用它，它仍然会操作创建它的原始变量。
    
    <CodeDemo filePath="/react/useState3.txt"/>
  </TabItem>
  <TabItem value="向 Setter 传递函数">
    
    当变量的新状态是基于变量之前的状态计算得出时，应该使用这种方法。通过传递一个函数，可以确保 setter 函数总是接收到变量的最新值。
    
    <CodeDemo filePath="/react/useState4.txt"/>
  </TabItem>
</Tabs>

### useReducer

useReducer hook 是 useState 的替代方案，它适用于复杂的状态更新或新状态依赖于旧状态的情况。useState 仅接收一个初始状态作为其参数，但 useReducer 接收一个初始状态和 reducer 作为实参。reducer 是一个纯函数，它接收当前状态和一个名为 action 的对象，并返回新状态。

```js title="reducer 函数签名"
(state, action) => newState;
```

useReducer hook 返回一个值和 dispatch 函数。dispatch 函数可用于响应事件，但它不使用值来设置状态变量，而是 action 对象。action 对象具有类型和可选的有效负载。

```jsx title="示例"
import { useReducer } from 'react';

const initialState = {
  count: 0,
};

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      // 这种方式确保了原始状态对象不会被修改，从而保持状态的不可变性，使得 React 能够正确地检测和响应状态的变化。
      // default
      return { ...state, count: state.count + 1 };

    case 'decrement':
      // default
      return { ...state, count: state.count - 1 };

    default:
      throw new Error('错误的 action');
  }
}

const App = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <h1>计算器 {state.count}</h1>
      <button onClick={() => dispatch({ type: 'increment' })}>increment</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>decrement</button>
    </div>
  );
};

export default App;
```

### useContext

全局数据是程序中所有组件或多个组件都使用的数据，如主题或用户偏好。对于 React 应用程序中的每一个组件，将全局数据从父组件传递到子组件可能是件麻烦事，特别是当组件树有多个层级时。

React Context 提供了一种在组件之间共享全局数据的方法，而不必将值作为 `props` 手动传递。`useContext` hook 接收一个 Context 对象作为参数，并返回该对象的最新值。

```jsx title="示例"
import { useContext } from 'react';
import themeContext from './themeContext.js';
const App = () => {
  const theme = useContext(themeContext);
  return <h1>Hello World! {theme.name}</h1>;
};

export default App;
```

### useRef

`useRef` hook 会返回一个带有可变属性 current 的 `ref` 对象。`ref` 对象的一个用途是以命令式访问 DOM。当附加了 `ref` 的 DOM 节点发生变化时，`ref` 对象的当前属性将被更新。而对 `ref` 的更改不会导致组件重新渲染。

`useRef` 它能帮助引用一个不需要渲染的值。

```js
const ref = useRef(initialValue);
```

<Tabs>
  <TabItem value="使用用 ref 引用一个值">
    
    在组件顶层调用 `useRef` 声明一个或多个 `ref`。
    
    ```jsx
    import { useRef } from 'react';
    const intervalRef = useRef(0);
    ```

    `useRef` 返回一个具有单个 current 属性 的 `ref` 对象，并初始化为你提供的初始值。

    在后续的渲染中，`useRef` 将返回相同的对象。你可以改变它的 current 属性来存储信息，并在之后读取它。这会让人联想到 `state`，但是有一个重要的区别。

    改变 `ref` 不会触发重新渲染。这意味着 `ref` 是存储一些不影响组件视图输出信息的完美选择。例如，如果需要存储一个 interval ID 并在以后检索它，那么可以将它存储在 `ref` 中。只需要手动改变它的 current 属性 即可修改 `ref` 的值：

    <CodeDemo filePath="/react/useRef1.txt" />

  </TabItem>
  <TabItem value="通过 ref 操作 DOM">

    使用 `ref` 操作 DOM 是非常常见的行为。React 内置了对它的支持。


    <CodeDemo filePath="/react/useRef2.txt" />

  </TabItem>
  <TabItem value="避免重复创建 ref 的内容">

    虽然 `new User()` 的结果只会在首次渲染时使用，但是依然在每次渲染时都在调用这个方法。如果是创建昂贵的对象，这可能是一种浪费。

    <CodeDemo filePath="/react/useRef3-1.txt" title="重复创建 ref"/>

    为了解决这个问题，你可以像这样初始化 `ref`：

    <CodeDemo filePath="/react/useRef3-2.txt"/>

  </TabItem>
  <TabItem value="获取自定义组件的 ref">

    如果尝试像这样传递 `ref` 到自定义组件：你可能会在控制台中得到这样的错误：

    > Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?

    ```jsx
    const inputRef = useRef(null);

    return <MyInput ref={inputRef} />;
    ```

    默认情况下，自定义组件不会暴露它们内部 DOM 节点的 `ref`。 为了解决这个问题，首先，找到想获得 `ref` 的组件，然后像这样将其包装在 `forwardRef` 里。


    <CodeDemo filePath="/react/useRef4.txt"/>

  </TabItem>
</Tabs>

### useEffect

`useEffect` hook 接收一个函数作为从参数，默认情况下，它将在每次渲染函数组件后运行该函数。`useEffect` hook 可以用来模拟类组件中的 `componentDidMount()`、`componentDidUpdate()` 和 `componentWillUnmount()` 生命周期方法。

useEffect 的目的时允许你在函数组件中运行具有副作用的命令式代码。这些副作用在函数组件中时不允许存在的，比如网络请求、设置计时器和直接操作 DOM。这些类型的操作在函数组件中时不可能实现的，原因是函数组件本质上只是组件的 render 方法。render 方法中不应该产生副作用，即使在类组件中也是如此，因为 render 方法可能会覆盖任何副作用的结果。相反，副作用应该在 render 方法运行后和更新 DOM 后执行。

这就是为什么要在生命周期方法内处理副作用的原因。

<Tabs>
  <TabItem value="默认行为">
    `useEffect` 最基本的形式中，只接收一个函数，并在每次渲染完成后执行该函数。
    <CodeDemo filePath="/react/useEffect0.txt" />
  </TabItem>
  <TabItem value="模拟 componentDidMount 方法">
    
    `useEffect` 默认行为上每次渲染组件都运行函数，如果你只希望在初始渲染上使用 `useEffect`，可以自定义 `useEffect` 行为，向它传递可选的第二个实参。当将空数组作为第二参数传递时，它模拟了 `componentDidMount()` 生命周期方法。
    
    <CodeDemo filePath="/react/useEffect1.txt" />
  </TabItem>
  <TabItem value="模拟 componentDidUpdate 方法">

    向 `useEffect` 第二参数传递依赖项，当依赖性更新，触发 `useEffect`。

    <CodeDemo filePath="/react/useEffect2.txt" />

  </TabItem>
  <TabItem value="模拟 componentWillUnmount 方法">
    
    如果使用 `useEffect` 来设置订阅、设置事件监听器或创建计时器，那么就有可能将内存泄露问题引入应用程序员中，故需要在组件卸载前清理它们。在函数组件中使用 `useEffect` 后如果要进行清理，可以从传递给 `useEffect` 的函数中返回一个函数，这个返回的函数会在组件从用户界面中被移除前运行。
    
    <CodeDemo filePath="/react/useEffect3.txt" />
  </TabItem>
</Tabs>

因为 `useEffect` 是异步的，并且在组件渲染后运行，所以它是执行异步任务（例如获取数据）的理想场所。

```js title="异步代码执行"
useEffect(() => {
  async function getData() {
    const result = await fetch('http://localhost:8080/api/v3');
  }
  getData();
}, []);
```

### useCallback

通常，你在组件中定义的函数会在每次渲染时重新创建。这通常不是问题。然而，有时候需要（或出于性能原因）返回函数的缓存版本，以使其在渲染之前保持可用。这就是 `useCallback` 的作用。

使用 `useCallback` hook 去包裹函数，获取函数的缓存，在函数的依赖项更新时，再重新创建函数。

```jsx title="试验组件定义的函数是否每次渲染会重新创建"
import { useEffect, useState } from 'react';

function App() {
  const [count, setCount] = useState(0);

  // default-start
  const handleSomething = () => {
    console.log('触发了 handleSomething');
  };
  // default-end

  // default-start
  useEffect(() => {
    handleSomething();
  }, [handleSomething]);
  // default-end

  return (
    <button onClick={() => setCount(prev => prev + 1)}>触发组件渲染</button>
  );
}

export default App;
```

在上诉代码中，`useEffect` 依赖于 handleSomething 更新，如果重新渲染会导致重新创建 handleSomething 函数，那么就会触发 `useEffect`。结果不言而已会触发 `useEffect`。

```jsx
import { useCallback, useEffect, useState } from 'react';

function App() {
  const [count, setCount] = useState(0);
  // success
  const [list, setList] = useState([]);

  // success-start
  const handleSomething = useCallback(() => {
    console.log('触发了 handleSomething');
  }, [list]);
  // success-end

  // default-start
  useEffect(() => {
    handleSomething();
  }, [handleSomething]);
  // default-end

  return (
    <div>
      <button onClick={() => setCount(prev => prev + 1)}>触发组件渲染</button>
      // success
      <button onClick={() => setList(prev => [...prev, prev.length])}>
        更新 list，触发函数重新创建
      </button>
    </div>
  );
}

export default App;
```

### useMemo

使用 `useMemo` hook 可以在函数组件的渲染之间存储值。它的用法与 `useCallback` 相同，只是它可以缓存任何值类型，而不仅限于函数。

和 `useCallback` 一样，使用 `useMemo` 有两个原因：

- 解决不必要的渲染问题
- 解决与计算成本昂贵有关的性能问题

在某些情况下，组件可能会因为父组件的重新渲染而不必要地重新渲染。`useMemo` 可以用来缓存计算结果，避免不必要的渲染。

```jsx title="解决不必要的渲染问题"
import React, { useState, useMemo } from 'react';

const ChildComponent = ({ count }) => {
  console.log('ChildComponent rendered');
  return <div>Count: {count}</div>;
};

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  const memoizedCount = useMemo(() => {
    return count;
  }, [count]);

  return (
    <div>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
        placeholder="Type something"
      />
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <ChildComponent count={memoizedCount} />
    </div>
  );
};

export default ParentComponent;
```

有些计算非常耗时，如果每次渲染都重新计算，会影响性能。`useMemo` 可以缓存计算结果，只有在依赖项变化时才重新计算。

```jsx title="解决与计算成本昂贵有关的性能问题"
import React, { useState, useMemo } from 'react';

const expensiveCalculation = num => {
  console.log('Calculating...');
  // 模拟耗时计算
  for (let i = 0; i < 1000000000; i++) {}
  return num * 2;
};

const ExpensiveComponent = () => {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  const calculatedValue = useMemo(() => {
    return expensiveCalculation(count);
  }, [count]);

  return (
    <div>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
        placeholder="Type something"
      />
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <div>Calculated Value: {calculatedValue}</div>
    </div>
  );
};

export default ExpensiveComponent;
```

### useDebugValue

`useDebugValue` 是 React 提供的一个 Hook，用于在 React 开发者工具中*显示自定义 Hook* 的标签和调试信息。它主要是为了提高*自定义 Hook 的可调试性和可读性*，使得在调试复杂应用程序时更容易理解和分析 Hook 的行为。

`useDebugValue` 接受一个参数，可以是任意类型的值，用来描述当前 Hook 的状态或一些调试信息。

```js title="示例"
import React, { useState, useEffect, useDebugValue } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    // 假设有一个订阅函数来监听好友状态
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  }, [friendID]);

  // 在开发者工具中显示调试信息
  useDebugValue(isOnline ? 'Online' : 'Offline');

  return isOnline;
}
```

### useSyncExternalStore

`useSyncExternalStore` 是 React 18 引入的一个 Hook，用于订阅外部存储（如全局状态管理器、WebSocket 数据源等），并确保在更新时同步获取最新的存储值。它提供了一种方式，让组件可以安全、同步地读取外部存储的数据。

<Tabs>
  <TabItem value="语法">
    `useSyncExternalStore` 接受三个参数：

    `subscribe`
    > 一个函数，用于订阅存储的变化。它返回一个取消订阅的函数。

    `getSnapshot`
    > 一个函数，用于获取当前的存储值。

    <p className="optional">`getServerSnapshot`</p>
    > 一个函数，用于在服务器渲染时获取当前的存储值。

  </TabItem>
  <TabItem value="示例">
    <CodeDemo filePath="/react/useSyncExternalStore.txt"/>
  </TabItem>
</Tabs>

### 自定义 Hook

自定义 hook 是利用内置 hook 来封装可重用功能的函数。通过创建自定义 Hook，可以将组件中的复杂逻辑提取到独立的函数中，从而使代码更模块化和可重用。自定义 Hook 使得 React 组件更具可读性和可维护性。

自定义 hook，像内置 hook 一样，名称以 use 开发，这是一种约定俗成，而不是强制要求。要编写自定义 hook，在函数内至少使用一个或多个内置 hook，并从该函数导出一个值。

```js title="hook 示例：useCustomHook.js"
import { useState } from 'react';

function useCustomHook(initalValue = 0) {
  const [count, setCount] = useState(initalValue);
  const increment = () => {
    setCount(prev => prev + 1);
  };

  const decrement = () => {
    setCount(prev => prev - 1);
  };

  return [count, increment, decrement];
}

export default useCustomHook;
```

自定义 Hook 可以返回任意类型的值，包括状态、函数、对象、数组等。返回值将被解构或直接使用在组件中。

可以非常简单使用计数器功能，且可以简单复用。

```jsx title="使用 useCustomHook"
import useCustomHook from './useCustomHook.ts';

export default function App() {
  const [count, increment, decrement] = useCustomHook();

  return (
    <div>
      <h1>计数器 {count}</h1>

      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}
```

## 路由

React Router是为React（一个用于构建用户界面的 JavaScript 库）设计的一个功能齐全的可以用在客户端和服务端的路由库，它可以在React运行的地方运行，在web上，node.js在服务器上，以及React Native上。

### 安装

```bash npm2yarn
npm install react-router-dom@6 history@5
```

### 连接路由

首先，我们想把你的应用连接到路由: `BrowserRouter`，并用它包裹你的整个应用。

```js
import { BrowserRouter } from 'react-router-dom';
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>,
);
```

### 添加导航

在 `App.js` 组件导入 `Link` 并添加一些全局导航，帮助应用实现跳转。

```js title="App.js"
import { Link } from 'react-router-dom';

function App() {
  return (
    <div>
      <Link to="/">Home</Link>
      <Link to="/about">About</Link>
      <Link to="/profile">Profile</Link>
    </div>
  );
}

export default App;
```

你还可以使用 `NavLink`，它是 `Link` 组件的升级版，用于给当前点击链接，追加一个calss类名样式，默认active

```css title="App.css"
.active {
  color: red;
}
```

当前激活的链接会自动高亮红色链接。

```js title="App.js"
import { NavLink } from 'react-router-dom';
import './App.css';

function App() {
  return (
    <div>
      <NavLink to="/">Home</NavLink>
      <NavLink to="/about">About</NavLink>
      <NavLink to="/profile">Profile</NavLink>
    </div>
  );
}

export default App;
```

如果需要修改默认类名，向 className 传入一个回调函数，函数接收 isActive 参数，渲染高亮类名。

```jsx
<NavLink
  to="/home"
  className={({ isActive }) => {
    return isActive ? 'custom-active' : '';
  }}
>
  Home
</NavLink>
```

### 注册路由

使用 Route 将组件注册成路由组件，并通过匹配 URL 来切换路由组件时，需要将它们包裹在 Routes 组件中，以便监视 URL 的变化。

```js title="App.js"
import React from 'react';
import { Routes, Route, Link } from 'react-router-dom';

const Home = () => <h2>Home Page</h2>;
const About = () => <h2>About Page</h2>;
const Profile = () => <h2>Profile Page</h2>;

function App() {
  return (
    <div>
      <ul>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/profile">Profile</Link>
      </ul>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/profile" element={<Profile />} />
      </Routes>
    </div>
  );
}

export default App;
```

### 添加“无匹配”路由

如果您单击一些链接使页面变为空白，并没有像您预期的那样进行，那是因为我们定义的所有路由都匹配不到我们点击的 URL.

```jsx
const NotFoundPage = () => <h2>NotFoundPage</h2>;

<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/about" element={<About />} />
  <Route path="/profile" element={<Profile />} />
  <Route path="*" element={<NotFoundPage />} />
</Routes>;
```

### 嵌套路由

设置二级路由链接时，可以是 `to="son1"`、`to="./son1"`，但不能是 `to="/son1"`，因为它会重置为一级路由。

```jsx
import React from 'react';
import { Routes, Route, Link } from 'react-router-dom';

// default-start
const Home = () => (
  <div>
    <h1>Home Page </h1>
    <Link to="son1">son1</Link>
    <Link to="son2">son2</Link>
  </div>
);
// default-end

const About = () => <h2>About Page</h2>;
const Profile = () => <h2>Profile Page</h2>;
const Son1 = () => <h3>Son1</h3>;
const Son2 = () => <h3>Son2</h3>;

function App() {
  return (
    <div>
      <ul>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/profile">Profile</Link>
      </ul>

      <Routes>
        // default-start
        <Route path="/" element={<Home />}>
          <Route path="son1" element={<Son1 />} />
          <Route path="son2" element={<Son2 />} />
        </Route>
        // default-end
        <Route path="/about" element={<About />} />
        <Route path="/profile" element={<Profile />} />
      </Routes>
    </div>
  );
}

export default App;
```

嵌套路由中，需要使用 `<Outlet>` 设置子路由的路由的位置，即在何处渲染子路由。

```jsx
import { Outlet } from 'react-router-dom';

const Home = () => (
  <div>
    <h1>Home Page </h1>
    <Link to="/son1">son1</Link>
    <Link to="/son2">son2</Link>
    <Outlet />
  </div>
);
```

### 默认路由

在路由组件内再次注册子路由，使用 `index` 指定默认渲染子路由（ 或者 `path` 为空）。

```js
<Route path="/" element={<Home />}>
  <Route index element={<Son1 />} />
  <Route path="son1" element={<Son1 />} />
  <Route path="son2" element={<Son2 />} />
</Route>
```

### 路由表

创建一个路由表是管理复杂应用中的路由配置的好方法。路由表将所有的路由集中在一个地方，便于维护和修改。

```js title="路由表（routes.js）"
import { Link, Outlet } from 'react-router-dom';

const Home = () => (
  <div>
    <h1>Home Page </h1>
    <Link to="/son1">son1</Link>
    <Link to="/son2">son2</Link>
    <Outlet />
  </div>
);
const About = () => <h2>About Page</h2>;
const Profile = () => <h2>Profile Page</h2>;
const Son1 = () => <h3>Son1</h3>;
const Son2 = () => <h3>Son2</h3>;
const NotFoundPage = () => <h2>NotFoundPage</h2>;

const routes = [
  {
    path: '/',
    element: <Home />,
    children: [
      {
        path: '',
        element: <Son1 />,
      },
      {
        path: 'son1',
        element: <Son1 />,
      },
      {
        path: 'son2',
        element: <Son2 />,
      },
    ],
  },
  {
    path: '/about',
    element: <About />,
  },
  {
    path: '/profile',
    element: <Profile />,
  },
  {
    path: '*',
    element: <NotFoundPage />,
  },
];

export default routes;
```

借助 `useRoutes` hook 可以帮你快速将路由表进行注册。

```js title="App.js"
import React from 'react';
import { Link, useRoutes } from 'react-router-dom';
import routes from './routes';

function App() {
  // default
  const element = useRoutes(routes);
  return (
    <div>
      <ul>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/profile">Profile</Link>
      </ul>
      {element}
    </div>
  );
}

export default App;
```

类组件不能使用 React 的 Hooks，因此无法使用 `useRoutes`。但是，我们可以通过传统的方法，比如使用 map 函数，将路由表渲染出来。

```jsx
import routes from './routes';

<Routes>
  {routes.map((route, index) => (
    <Route key={index} path={route.path} element={route.element} />
  ))}
</Routes>;
```

### 路由参数

#### params 参数

在注册路由或路由表绑定 `path` 来传递 params 参数，在函数组件使用 `useParams` hook 获取解析。

```js title="注册路"
<Route path="/profile/:id"></Route>
```

`:id` 被 `useParams` 解析，通过 `params.id` 获取。

```js title="Profile 组件"
import React, { useEffect } from 'react';
import { useParams } from 'react-router-dom';

function Profile() {
  const params = useParams();

  useEffect(() => {
    console.log(params);
  }, []);

  return <h1>Profile</h1>;
}

export default Profile;
```

#### search 参数

传递参数的方式不变，也不需要声明接受，但解析参数需要使用 `useSearchParams()` 接收参数。该方法返回一个包含两个元素的数组：`searchParams` 参数和修改 `setSearchParams` 参数的方法（名字随意，尽可能规范取名）。

```jsx
// 点击跳转
<Link to="/profile?name=mofan">Profile</Link>;

// Profile 组件
import React, { useEffect } from 'react';
import { useSearchParams } from 'react-router-dom';

function Profile() {
  const [searchParams, setSearchParams] = useSearchParams();

  useEffect(() => {
    console.log(searchParams.get('name')); // mofan
  }, []);

  return <h1>Profile</h1>;
}

export default Profile;
```

#### state 参数

使用 `state` 参数传递数据的方法比直接在 URL 中传递参数更灵活和安全，特别适合传递复杂数据。你可以通过 `Link` 或 `navigate` 方法来设置 `state` 参数，并通过 `useLocation` 钩子来获取它。

```js
<Link to="/profile" state={{ userId: 1, userName: 'John' }}>
  Profile
</Link>
```

```js title="Profile 组件"
import React, { useEffect } from 'react';
import { useLocation, useParams, useSearchParams } from 'react-router-dom';

function Profile() {
  const state = useLocation();

  useEffect(() => {
    console.log(state);
  }, []);

  return <h1>Profile</h1>;
}

export default Profile;
/**
* {
    "pathname": "/profile",
    "search": "",
    "hash": "",
    "state": {
        "userId": 1,
        "userName": "John"
    },
    "key": "wwwfnyn1"
}
*/
```

### 编程式路由导航

编程式路由导航是指在 React 中通过编程方式（而不是通过用户点击链接或按钮）进行页面导航。在 React Router 中，你可以使用 `useNavigate` 对象来实现编程式导航。

```jsx
import React, { useState } from 'react';
import { useNavigate, useRoutes } from 'react-router-dom';
import routes from './routes';

const App = () => {
  const element = useRoutes(routes);
  const [path, setPath] = useState();
  // default
  const navigate = useNavigate();

  // default-start
  const handleNavigate = () => {
    navigate(path);
  };
  // default-end

  return (
    <div>
      <input
        placeholder="请输入路径"
        onChange={event => setPath(event.target.value)}
      />
      <button onClick={handleNavigate}>导航</button>

      {element}
    </div>
  );
};

export default App;
```

使用 `useNavigate` 进行路由导航时，可以通过第二个参数来传递额外的数据，这些数据可以在目标路由组件中进行接收和处理。第二参数是一个可选对象，有如下属性：

<Tabs>
  <TabItem value="replace">
    指定 `replace: true` 将导致导航替换历史堆栈中的当前条目，而不是添加新条目。

    <CodeDemo filePath="/react/useNavigate1.txt"/>

  </TabItem>
  <TabItem value="state">
    您可以包含一个可选的 `state` 值来存储在历史状态中，然后您可以通过 `useLocation` 在目标路由上访问该值。
    
    <CodeDemo filePath="/react/useNavigate2.txt"/>

  </TabItem>
  <TabItem value="preventScrollReset">
    使用 `<ScrollRestoration/>` 组件时，您可以通过 `options.preventScrollReset` 禁用将滚动重置到页面顶部
  </TabItem>

  <TabItem value="relative">
    默认情况下，导航是相对于路由层次结构 `relative: "route"` 的，因此 `..` 将上升一个 Route 级别。有时，您可能会发现匹配的 URL 模式对于嵌套没有意义，并且您更愿意使用相对路径路由。您可以使用 `relative: "path"` 选择此行为：

    <CodeDemo filePath="/react/useNavigate3.txt"/>

  </TabItem>
</Tabs>

`useNavigate` 可以传递数字，代表前进或后退几步。

```js
const navigate = useNavigate();

function back() {
  navigate(1);
}

function forward() {
  navigate(-1);
}
```

### 路由拦截

在React中实现路由拦截通常涉及到使用React Router库来管理路由，以及在需要时添加自定义逻辑来拦截和处理路由跳转或访问。

封装一个通用的权限组件，在是否获取到权限时，渲染目标组件还是登录组件。

```jsx title="PermissionRoute.jsx"
import React from 'react';
import { Navigate, Route, useNavigate } from 'react-router-dom';

function PermissionRoute({ Component }) {
  const navigate = useNavigate();

  function getToken() {
    return localStorage.getItem('token') || false;
  }

  if (!getToken()) {
    return <Navigate to="/login" />;
  }

  return Component;
}

export default PermissionRoute;
```

```jsx title="App.js"
const App = () => {
  return (
    <div>
      <Link to="/home">Home</Link>
      <Link to="/about">About</Link>
      <Routes>
        <Route path="/login" element={<Login />} />
        <Route path="/home" element={<Home />} />
        {/* 需要权限才能访问的组件 */}
        <Route
          path="/about"
          element={<PermissionRoute Component={<About />} />}
        />
      </Routes>
    </div>
  );
};

export default App;
```

### 类组件跳转

在 React Router v6 中，`withRouter` 高阶组件已经被移除，但你仍然可以在类组件中实现编程式导航。为了在类组件中使用导航功能，可以通过 `useNavigate` 钩子创建一个函数组件包装器，将导航功能注入到类组件中。

首先，我们需要创建一个 `withRouter` 高阶组件来将 `navigate` 函数注入到类组件的 `props` 中。

```jsx title="withRouter.jsx"
import React from 'react';
import { useNavigate } from 'react-router-dom';

export const withRouter = Component => {
  const Wrapper = props => {
    const navigate = useNavigate();
    return <Component {...props} navigate={navigate} />;
  };

  return Wrapper;
};
```

```jsx title="示例"
import React from 'react';
import withRouter from './withRouter.jsx';

class About extends React.Component {
  handleClick() {
    this.navigate('/home');
  }

  render() {
    return <h1 onClick={() => this.handleClick()}>About</h1>;
  }
}

export default withRouter(About);
```

### 路由 Hooks

路由钩子（Hooks）提供了一种简单且强大的方式来访问和操作路由信息。这些钩子使得在函数组件中操作路由变得更加方便。

**常用路由钩子**

- [ ] `useNavigate`
- [ ] `useParams`
- [ ] `useLocation`
- [ ] `useSearchParams`
- [ ] `useRoutes`

**其它 hooks**

<Tabs>
  <TabItem value="useOutlet">

    `useOutlet` 用于在布局组件中渲染子路由的内容。通常用于嵌套路由中。

    <CodeDemo filePath="/react/useOutlet.txt"/>

  </TabItem>
  <TabItem value="useOutletContext">
    
    `useOutletContext` 用于在子路由组件中获取父路由通过 `<Outlet/>` 提供的上下文。

    <CodeDemo filePath="/react/useOutletContext.txt"/>

  </TabItem>
  <TabItem value="useResolvedPath">
    
    `useResolvedPath` 用于解析给定路径并返回包含路径信息的对象。主要用于创建自定义导航逻辑。

    <CodeDemo filePath="/react/useResolvedPath.txt"/>

  </TabItem>
  <TabItem value="useMatch">

    `useMatch` 用于检查当前 URL 是否与给定的路径匹配，并返回匹配的详细信息。

    <CodeDemo filePath="/react/useMatch.txt"/>

  </TabItem>
  
  <TabItem value="useNavigationType">

    `useNavigationType` 用于获取当前导航的类型（PUSH、POP 或 REPLACE），主要用于对导航行为进行更细粒度的控制。

    <CodeDemo filePath="/react/useNavigationType.txt"/>

  </TabItem>
</Tabs>

## 错误边界

### 什么是错误边界

错误边界是一个组件，用于捕获其子组件中发生的错误，一旦捕获到错误，错误边界就可以提供一个回退 UI 并记录错误，还可以为用户提供一种不需要刷新浏览器窗口就能够恢复使用 UI 的方法。

### 实现错误边界

在 React 中，错误边界不是特定的函数或组件。相反，任何组件都可以定义一个静态的 `getDerivedStateFromError` 或 `componentDidCatch` 生命周期方法（或两者兼而有之）。因为错误边界使用生命周期方法，所以它们必须是类组件。一旦定义了 ErrorBoundary 组件，就可以根据需要多次重用它。因此，如果需要，ErrorBoundary 组件可以是唯一需要编写的类组件。

```js title="构建 ErrorBoundary 组件"
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
    };
  }

  static getDerivedStateFromError(error) {
    return {
      hasError: true,
    };
  }

  componentDidCatch(error, info) {
    // 记录日志
    console.log(error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h1>遇到错误了，请稍后尝试刷新</h1>;
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
```

**1. getDerivedStateFromError 是一种静态方法**

静态方法通常用于定义整个类的功能，例如实用程序。在 React 中，`getDerivedStateFromError` 生命周期方法被定义为静态方法，是为了使它们更难产生副作用。

**2. getDerivedStateFromError 在渲染阶段运行**

在组件生命周期中的渲染阶段运行，不允许执行具有副作用的操作，如记录错误。执行副作用的正确时间是在渲染阶段之前或之后。如果要执行副作用，可以借助 `componentDidCatch` 生命周期。

**3. getDerivedStateFromError 将错误作为参数接收**

当使用 `getDerivedStateFromError` 的组件的后代组件中发生错误时，将调用该方法并传递错误消息。错误消息时一个字符串，包含有关错误发生的位置和错误内容。

**4. getDerivedStateFromError 应返回一个对象以更新状态**

`getDerivedStateFromError` 的返回值将用于更新状态。除了更新 hasError 的值，也可能将错误本身存储在状态中。

```jsx
class ErrorBoundary extends React.Component {
  static getDerivedStateFromError(error) {
    return {
      hasError: true,
      error,
    };
  }
}
```

**5. 使用 componentDidCatch() 记录错误**

当 React 组件树中发生错误时，要尽量减少它对用户的影响，但如果能实际了解错误发生的原因和位置，将有助于防止未来再次发生错误。这就是 `componentDidCatch` 生命周期方法能发挥作用的地方。

**6. 使用日志记录服务**

在开发过程中，将错误记录到控制台时可以的，但一旦应用程序上线并被其他人使用，控制台窗口中显示的所有日志消息将保留在用户的控制台中，这没有任何好处。

要了解实际用户遇到的错误，要么需要用户来告诉你（除非错误非常严重，否则这是不可能的），要么需要实现一个系统，能够在用户浏览器外自动记录错误。

基于云的日志记录服务可以捕获应用程序中发生的事件（如错误），并提供报告，你可以使用这些报告来改进应用程序或获取有关用户如何使用应用程序的信息。

**7. 重置状态**

如果触发错误边界的错误是临时错误，例如在网络服务不可用时，那么提供一种让用户重试的方法可以改善用户体验。

由于 ErrorBoundary 组件根据 hasError 状态值确定是否渲染回退UI或其子组件，因此重置 hasError 的值将导致它再次尝试渲染子组件。

渲染因网络请求发生错误的组件，可以在 ErrorBoundary 组件添加一个重试按钮，以重新渲染子组件。

```jsx title="示例"
class ErrorBoundary extends React.Component {
  render() {
    if (this.state.hasError) {
      return (
        <h1>
          遇到错误了，
          <button onClick={() => this.setState({ hasError: false })}>
            请重试
          </button>
        </h1>
      );
    }

    return this.props.children;
  }
}
```

### 错误边界无法捕获的错误

错误边界是捕获组件中大多数常见错误的绝佳工具，但错误边界无法处理某些类型的错误，如下：

- ErrorBoundary 中的错误
- 事件处理程序中的错误
- 服务器端渲染中的错误
- 异步代码中的错误

## Context API

在 React 中将数据从父组件传递子组件的主要方法是通过 props。然而，在某些情况下，props 用起来会很繁琐，并且会导致代码更难阅读和维护。为此，Context API 应运而生。

### 什么是 Prop drilling

Prop drilling（属性传递）指的是将属性从一个组件传递到另一个组件的过程，特别是在组件层级较深时可能会出现的一种情况。这种情况通常发生在父组件需要将属性传递给深层次的子组件，而中间的组件并不需要这些属性，但需要将它们传递下去的情况。

### Context API

属性传递不一定是一个问题。在大多数情况下，这正是你应该使用的方法。然而，如果应用程序中有数据或函数可以视为“全局的”（或者对于特定的组件树是全局的），那么使用 Context 可以避免连续属性传递带来的问题。

#### 创建 Context

要创建 Context，可以使用 `React.createContext`.

```js title="ThemeContext.js"
import React from 'react';

let defaultValue = {
  theme: 'dark',
};

const ThemeContext = React.createContext(defaultValue);

export default ThemeContext;
```

`React.createContext` 方法返回一个 Context 对象。传递给 createContext 的 defaultValue 参数是在没有匹配的 Provider 时将提供给后代的数据。由于默认值很可能永远都用不上，许多开发人员将默认值保留为 `undefined`, 或者将其设置为某个示例对象。

#### 创建 Provider

Context Provider 是一个组件，它将对上下文数据的变化发布给后代组件。Provider 组件接收一个名为 value 的属性，该属性将重写 `React.createContext` 中设置的 defaultValue。

```jsx
return (
  <ThemeContext.Provider value={{ theme: 'light' }}>
    <OtherComponent />
  </ThemeContext.Provider>
);
```

Provider 组件可以根据需要多次使用，并且可以嵌套在组件树中。使用 Context 的组件将会访问最近的 Provider 祖先组件，如果没有 Provider 祖先组件，则会使用 Context 的默认值。

#### 使用 Context

一旦有了 Context 和 Provider，后代组件就可以成为 Context 的 Consumer（消费者）。Context Consumer 将在 Provider 的值发生变化时重新渲染。

在函数组件和类组件中，它们消费的方式有所不同：

<Tabs>
  <TabItem value="函数组件">
    可以通过使用 `Context.Consumer` 组件或使用 `useContext` hook 在函数组件中使用 Context。

    <CodeDemo filePath="/react/useContext1.txt" title="Context.Consumer 示例"/>

    <CodeDemo filePath="/react/useContext2.txt" title="useContext 示例"/>

  </TabItem>
  <TabItem value="类组件">
    
    在类组件中使用 Context 有两种方式：设置类的 `contextType` 属性和使用 `Context.Consumer` 组件。

    <CodeDemo filePath="/react/useContext3.txt" title="contextType 示例"/>

    <CodeDemo filePath="/react/useContext4.txt" title="Context.Consumer 示例"/>

  </TabItem>
</Tabs>

## Portal

在 React 中，Portal 是一种特殊的组件渲染技术，允许你将子组件渲染到 DOM 中的任意位置，而不受父组件层级的限制。这在处理一些特定的 UI 情况下非常有用，例如在模态框、弹出菜单或者悬浮组件中。

首先，在项目中创建一个 Portal 组件，通常是一个简单的函数组件，用于渲染它的子组件到指定的 DOM 节点上。

```html title="index.html"
<!-- public/index.html -->
<!doctype html>
<html lang="en">
  <head>
    ...
  </head>
  <body>
    <div id="root"></div>
    <div id="portal-root"></div>
  </body>
</html>
```

```jsx title="创建 Portal 组件"
// Portal.jsx
import React from 'react';
import ReactDOM from 'react-dom';

const Portal = ({ children }) => {
  const portalRoot = document.getElementById('portal-root'); // 这里的 'portal-root' 是一个在 public/index.html 中定义的 div id
  return ReactDOM.createPortal(children, portalRoot);
};

export default Portal;
```

在需要使用 Portal 渲染的组件中，将子组件包裹在 Portal 组件中。

```jsx title="在组件中使用 Portal"
import React from 'react';
import Portal from './Portal.jsx';
const App = () => {
  return (
    <Portal>
      <div className="modal">
        <h2>Modal Title</h2>
        <p>This is the content of the modal.</p>
      </div>
    </Portal>
  );
};

export default App;
```

### 冒泡问题

Portal 可以渲染组件到任意节点下，即使渲染到 body 节点下与 root 跟节点成为兄弟节点，在 Portal 组件触发事件，仍然会冒泡触发 root 节点事件。

:::tip 深入探讨
在 React 中，事件处理是通过合成事件系统管理的，而 Portal 本质上是将组件渲染到 DOM 树中的不同位置，但在 React 组件层次结构中，它仍然被认为是 root 根节点的子节点。因此，如果你在 Portal 中创建了一个节点并且在该节点上触发了事件，事件会冒泡到 Portal 的直接父级组件，然后继续向上冒泡直到根节点。这样确保了事件在 React 组件树中正确地传递和处理。
:::
